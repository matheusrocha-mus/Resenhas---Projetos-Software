# Engenharia de Software Moderna - Marco Tulio Valente

## Capítulo 7

Nesse capítulo o autor apresenta uma exploração detalhada sobre arquitetura de software. O autor inicia destacando que a arquitetura de software se preocupa com o "projeto em mais alto nível", focando na organização de componentes maiores, como módulos, subsistemas e serviços, em vez de classes individuais. Além disso, enfatiza que a arquitetura abrange decisões cruciais de projeto que, uma vez tomadas, são difíceis de reverter, como a escolha da linguagem de programação ou do banco de dados.

Em seguida, Marco Tulio traz uma contextualização históica com o Debate Tanenbaum-Torvalds. O Debate Tanenbaum-Torvalds foi uma discussão pública ocorrida em 1992 entre Andrew S. Tanenbaum, criador do sistema operacional MINIX, e Linus Torvalds, criador do Linux. A controvérsia central girava em torno das arquiteturas de núcleos de sistemas operacionais: Tanenbaum defendia os microkernels, que promovem modularidade e potencialmente maior estabilidade, enquanto Torvalds apoiava os monolíticos, enfatizando desempenho e simplicidade. Tanenbaum argumentava que o design monolítico do Linux era obsoleto e menos portátil, prevendo que a arquitetura x86 seria superada por outras. Torvalds, por outro lado, destacava que o Linux era desenvolvido para hardware disponível e popular na época, e que a escolha por um núcleo monolítico facilitava o desenvolvimento e a eficiência. Esse debate é significativo na história da computação, pois aborda questões fundamentais sobre design de sistemas operacionais e influenciou decisões arquiteturais em projetos subsequentes.

O capítulo segue explorando diversos padrões arquiteturais, começando pela Arquitetura em Camadas. Nesse modelo, o sistema é dividido em camadas hierárquicas, onde cada uma possui responsabilidades específicas e se comunica apenas com as camadas adjacentes. Um exemplo clássico é a arquitetura em três camadas: apresentação, aplicação e dados. A camada de apresentação lida com a interface do usuário, a de aplicação processa a lógica de negócios e a de dados gerencia o acesso ao banco de dados. Esse padrão é amplamente utilizado em sistemas de informação, pois facilita a manutenção e a escalabilidade.

Em seguida, o autor aborda a Arquitetura Model-View-Controller (MVC), uma das que mais trabalhamos no curso até então (como nas disciplinas de Trabalho Interdisciplinar e Programação Modular). Essa arquitetura surgiu no contexto das interfaces gráficas com o Smalltalk-80. O MVC divide a aplicação em três componentes principais: Modelo (gerencia os dados e a lógica de negócios), Visão (responsável pela apresentação) e Controlador (intermediário que lida com a entrada do usuário e atualiza o Modelo e a Visão). Essa separação permite que diferentes desenvolvedores trabalhem simultaneamente em componentes distintos, promovendo a especialização e facilitando a manutenção. No mercado, frameworks web como Django (Python) e Ruby on Rails adotam o padrão MVC, permitindo o desenvolvimento organizado e eficiente de aplicações web.

A discussão avança para a Arquitetura baseada em Microsserviços, com a qual temos trabalhado recorrentemente nas aulas de Projeto de Software. O autor explica que essa arquitetura ganhou destaque com a necessidade de escalabilidade e deploy contínuo em grandes sistemas. Nesse modelo, a aplicação é composta por pequenos serviços independentes que se comunicam geralmente por APIs RESTful. Cada microsserviço é responsável por uma funcionalidade específica e pode ser desenvolvido, implantado e escalado de forma independente. Empresas como Netflix e Amazon adotaram essa arquitetura (como foi comentado em sala) para permitir que diferentes equipes trabalhem em serviços distintos, agilizando o desenvolvimento e a implantação de novas funcionalidades. No entanto, o autor alerta para a complexidade adicional na gestão de comunicação entre serviços e no monitoramento de sistemas distribuídos.

O autor dedica um subtópico inteiro para abordar o gerenciamento de dados em arquiteturas de microsserviços, apontando que é recomendado que cada serviço possua seu próprio banco de dados, evitando o compartilhamento de um único banco entre múltiplos serviços. Essa independência assegura que cada equipe possa evoluir e escalar seu serviço de forma autônoma, sem criar gargalos ou dependências excessivas. No entanto, essa abordagem traz desafios, especialmente no que diz respeito à consistência de dados entre serviços distintos. Para manter a integridade e a consistência dos dados em um ambiente distribuído, técnicas como Sagas podem ser implementadas. Sagas são sequências de transações que garantem que, mesmo em caso de falhas, o sistema possa reverter ou compensar operações para manter um estado consistente. Essa estratégia é fundamental para assegurar que operações que abrangem múltiplos serviços sejam concluídas de maneira confiável, mesmo diante de falhas ou inconsistências temporárias.

Por fim, Marco Tulio conclui o tópico sobre arquitetura de microsserviços dissertando sobre as complexidades dessa arquitetura, e em que casos não faz sentido implementá-la. A comunicação entre serviços, que antes era uma simples chamada de método em um monolito, passa a depender de protocolos de rede, aumentando a latência e a possibilidade de falhas na comunicação. Além disso, garantir a consistência de dados se torna mais desafiador, muitas vezes exigindo a implementação de transações distribuídas ou mecanismos de compensação, como Sagas. Portanto, para sistemas menos complexos ou para equipes com recursos limitados, uma arquitetura monolítica pode ser mais adequada, oferecendo simplicidade e facilidade de gerenciamento. A decisão de adotar microsserviços deve ser cuidadosamente avaliada, considerando o contexto e as necessidades específicas do projeto.

O capítulo também explora padrões arquiteturais voltados para a comunicação assíncrona e o desacoplamento de componentes, como Filas de Mensagens e o padrão Publish/Subscribe. As Filas de Mensagens permitem que diferentes partes de um sistema se comuniquem de forma assíncrona, colocando mensagens em uma fila que podem ser processadas posteriormente por outros componentes. Isso é particularmente útil em sistemas que requerem alta disponibilidade e resiliência, pois permite que partes do sistema continuem operando mesmo que outras estejam temporariamente indisponíveis. Por exemplo, em uma plataforma de e-commerce, quando um pedido é realizado, uma mensagem pode ser colocada em uma fila para que o sistema de faturamento a processe posteriormente, garantindo que o usuário não precise esperar pelo processamento completo para receber a confirmação do pedido.

No padrão Publish/Subscribe, os emissores de mensagens (publishers) não enviam mensagens diretamente para receptores específicos. Em vez disso, as mensagens são categorizadas em tópicos, e os interessados (subscribers) se inscrevem nos tópicos de seu interesse. Quando uma mensagem é publicada em um tópico, todos os inscritos são notificados. Esse padrão é amplamente utilizado em sistemas que requerem distribuição de eventos para múltiplos componentes, como em aplicações de mercado financeiro, onde diferentes sistemas precisam ser notificados sobre alterações em preços de ações em tempo real.

O autor discute ainda outros padrões arquiteturais que atendem a necessidades específicas. A arquitetura de Pipes and Filters, por exemplo, é comum em sistemas que processam fluxos de dados, como compiladores, onde cada filtro transforma os dados e os passa adiante através de pipes. Já a arquitetura Cliente/Servidor é fundamental na implementação de serviços de rede, onde clientes solicitam serviços e servidores os fornecem, como em sistemas de banco de dados ou servidores web. Por fim, arquiteturas peer-to-peer distribuem responsabilidades entre todos os nós da rede, permitindo que cada nó atue tanto como cliente quanto como servidor, exemplificado por protocolos de compartilhamento de arquivos como o BitTorrent. A escolha do padrão arquitetural adequado depende das características e requisitos específicos de cada sistema.

Para concluir o capítulo, Marco Tulio aborda os chamados "anti-padrões arquiteturais" - em específico, ele explica um dos mais conhecidos, o "Big Ball of Mud" (Grande Bola de Lama), caracterizado por uma ausência de estrutura clara, onde qualquer módulo pode interagir com qualquer outro de maneira desorganizada. Essa falta de organização resulta em um emaranhado de dependências, tornando a manutenção e evolução do sistema extremamente difíceis. Sistemas que evoluem para esse estado frequentemente enfrentam desafios como aumento do tempo de aprendizado para novos desenvolvedores, introdução constante de bugs ao tentar corrigir problemas e dificuldade na implementação de novas funcionalidades. Para evitar cair nesse anti-padrão, é crucial investir em um design arquitetural bem definido desde o início, estabelecendo diretrizes claras de modularização e interação entre componentes.

Em resumo, o Capítulo 7 do livro "Engenharia de Software Moderna" oferece uma visão abrangente sobre diferentes padrões arquiteturais, destacando suas características, benefícios e desafios. O que mais gostei desse capítulo foi a ligação direta entre o mesmo e as nossas vivências como alunos de engenharia até então - já tivemos experiência com a arquitetura MVC e em todas as aulas de Projeto de Software até então temos praticado a diagramação de arquiteturas de microsserviços. Na minha opinião, nada é mais importante do que a prática, porém aprender mais sobre a esfera técnica e literária de arquiteturas às quais já fomos expostos anteriormente permite que criemos uma nova perspectiva e um outro nível de profundidade no entendimento das mesmas.